import fetch from 'node-fetch'
import sslCertificate from 'get-ssl-certificate'
import extractDomain from 'extract-domain'
import WebSocket from './web-socket.js'
import Traceroute from 'nodejs-traceroute'
import {subnetData, speedTestFunc} from './functions/functions'
import regeneratorRuntime from 'regenerator-runtime'
import {webServer} from './web_server'
import dns from 'dns'
import {pingFunc, clusterPingFunc, ipScanFunc} from './functions/ping-functions'
import {sshShell} from './functions/ssh-function'


class NetworkScanner{
  constructor(){
    this.commands = [],
    this._pollInterval = 10000
  }

  get sshCommands(){ return this.commands }

  set sshCommands(commands){
    if(!Array.isArray(commands)){
      throw new Error(`SSH commands must be an array not ${typeof commands}`)
    }else{
      this.commands = commands
    }
  }

  set pollInterval(val){
    if(isNaN(val)){
      throw new Error(`Poll interval must be an integer and not a ${typeof val}`)
    }else{
      this._pollInterval = val
    }
  }

  async poll(host, config){
    const p = await pingFunc(host, config)
    return p
  }

  clusterPing(array, cb){
    clusterPingFunc(array, (hosts)=>{cb(hosts)})
  }

  async ipScan(range, cb){
    ipScanFunc(range, (host)=>{ cb(host) })
  }

  getSubnet(subnet){
    if(!subnet.split('/')[1]){
      throw new Error(`${subnet} is an invalid subnet`)
    }
    return fetch(`https://networkcalc.com/api/ip/${subnet}?binary=1`)
      .then((res) => {
        return res.json()
      })
      .then((data)=>{
        const obj = subnetData(data)
        return obj
      })
  }

  async macLookup(mac){
    let res = await fetch(`https://api.macvendors.com/${mac}`)
    let data = await res.text()
    return data
  }

  async getSsl(url){
    const domain = extractDomain(url)
    let ssl = await sslCertificate.get(domain)
    return ssl
  }

  netServer(port){
    const server = new WebSocket.Server(port)
    return server.listen(port)
  }

  netClient(host){
    const client = new WebSocket.Client(host)
    return client
  }

  traceroute(dest, cb){
   try {
     const tracer = new Traceroute();
     tracer.on('hop', (hop) => {
       cb(hop)
     }).on('close', (code) => {
        return
      })
    tracer.trace(dest);
  } catch (err) {
     throw err
   }
  }

  monitorCluster(array){
    this.netServer(5000).on('connection', (socket)=>{
      let repeatPoll
      this.clusterPing(array, (host)=>{socket.emit('ping-data', (host))})
      repeatPoll = setInterval(()=>{
        this.clusterPing(array, (host)=>{
          socket.emit('ping-data', (host))
        })
      },this._pollInterval)
      let repeatLog
      socket.on('get-log',(node) => {
        repeatLog = setInterval(async()=>{
          let poll = await this.poll(node.host)
          socket.emit('get-log', poll)
        },1000)
      })
      socket.on('clear-log', (data)=>{ clearInterval(repeatLog) })
      socket.on('disconnect', () => {
        clearInterval(repeatPoll)
        clearInterval(repeatLog)
      })
    })
    return webServer()
  }

  lookup(domain, cb){
    return dns.lookup(domain, (err, addresses, family) => {
      if (err)
        throw err
      cb(addresses)
    })
  }

  async speedTest(connections){
    let speed = await speedTestFunc(connections)
    return speed
  }

  ssh(sshDetails, cb){
    const config = {
      host:sshDetails.host,
      port:sshDetails.port,
      user:sshDetails.user,
      password:sshDetails.password,
      commands:this.sshCommands
    }
    sshShell(config, (output) => { cb(output) })
  }
}

module.exports = NetworkScanner
